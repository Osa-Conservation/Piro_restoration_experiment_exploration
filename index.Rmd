---
title: "Osa Conservation: Piro Restoration Experiment"
author:
  - Osa Conservation Wildlife Team and Earthwatch
site: bookdown::test-bookdown
output: bookdown::gitbook
date: '`r paste("Updated on", Sys.Date())`'
documentclass: book
biblio-style: apalike
link-citations: yes
editor_options: 
  chunk_output_type: console
---

# Introduction

```{r c01, echo=F, message=F, include=F}
knitr::opts_chunk$set(echo = FALSE, message=F, warning=F)

library(dplyr)
library(leaflet)
library(units)
library(sf)
library(viridis)
library(kableExtra)
library(lubridate)
library(plotly)
library(googledrive)
library(purrr)
library(readxl)
library(leaflet.extras)
library(tidyr)

#drive_auth()
googledrive::drive_auth(path = Sys.getenv("GOOGLE_AUTHENTICATION_CREDENTIALS"))
data_path <- "data"
dir.create(data_path) 
#test2
# For when the trapping effort file is sorted
# googledrive::drive_auth(path = Sys.getenv("GOOGLE_AUTHENTICATION_CREDENTIALS"))
# 
```

```{r, echo=F, message=F, warning=F}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
knitr::include_graphics("./images/Banner_osa_and Earthwatch_mid.png")
```

The following represents the data exploration for the data collected during the collaboration between Osa Conservation and Earthwatch for the project entitled:

**A multi-taxa approach comparing the success of active tropical rainforest restoration with old-growth forest in Costa Rica.**

Also known as:

**The Piro Restoration Experiment**

The centralized document for the protocols used in this experiment lives [here](https://docs.google.com/document/d/11z94NQX6Oz3Eoyfs-HaDUQQkKXT1yKlZnzrT5vFTTcM/edit?usp=sharing). Note, as this is a working document only OC staff currently have access. 

## Study area and survey locations

```{r, c02, include=F, message=F, warning=F, results="hide"}
#Import the shapefiles for the maps
dir.create("shapefiles")
shp_folder <- drive_ls(path = as_id("1MhlqBbWVCaSoSiltC3SlGsEvltsVZvkC"), recursive=T)

for(i in 1:nrow(shp_folder))
{
  # if it has a file extension download it
  if(substr(shp_folder$name[i], (nchar(shp_folder$name[i]) - 3),(nchar(shp_folder$name[i]) - 3))==".")
  {
  drive_download(file = as_id(shp_folder$id[i]), path = paste0("shapefiles/", shp_folder$name[i]), overwrite = TRUE)
  }
}

trails <- st_read("shapefiles/trails_osa.shp")
trails<- st_zm(trails, drop = TRUE, what = "ZM")
plots <- st_read("shapefiles/Restoration_experiment_original.shp")
plots <- st_transform(plots, 4326)
plots<- st_zm(plots, drop = TRUE, what = "ZM")
# Update the column name
colnames(plots)[colnames(plots)=="plotID"] <- "plot_id"

plots_centroid <- st_centroid(plots)

roads <- st_read("shapefiles/roads_osa.shp")

# Import the plot locations
dir.create("data")
data_folder <- drive_ls(path = as_id("1dnLGAUTC0IQ9dSzC4l354whRrBXLNOM1"), recursive=F)
# Subset to just the datafolders
data_folder <- data_folder[substr(data_folder$name,1,4)=="Piro",]

# Remove the shortcut folders and replace them with the real file 
data_folder <- data_folder[!(data_folder$name %in% c("Piro_Restoration_Experiment_BATBOX_DATABASE", "Piro_Restoration_Experiment_BIRD_DATABASE")),]

for(i in 1:nrow(data_folder))
{
  drive_download(file = as_id(data_folder$id[i]), path = paste0("data/", data_folder$name[i]), overwrite = TRUE)
}

# Also grab the bird and batbox databases - as they are shortcuts

# Birds
drive_download(file = as_id("19xnEVq_EH3xkZe-Up3iK6hXROm3LUu9rITm7FCI1-9A"), path = paste0("data/", "Piro_Restoration_Experiment_BIRD_DATABASE"), overwrite = TRUE)


# Bats
drive_download(file = as_id("1mI3RhnR0WiuaK3TFnnF46xugKDRttKR8xe-lNCpeeXA"), path = paste0("data/", "Piro_Restoration_Experiment_BATBOX_DATABASE"), overwrite = TRUE)

# Read in the plot locations master list

locs_db <- read_excel("data/Piro_Restoration_Experiment_PLOT_MASTERLIST.xlsx", sheet="survey_locations")  

# Download the Wildlife Insights data and format it
data_folder <- drive_ls(path = as_id("1csFLXRj8rNYGlEA06nMn6fP0qC-f7XOA"), recursive=F)

for(i in 1:nrow(data_folder))
{
  drive_download(file = as_id(data_folder$id[i]), path = paste0("data/", data_folder$name[i]), overwrite = TRUE)
}

img <- read.csv("data/images.csv", header=T)
dep <- read.csv("data/deployments.csv", header=T)

img$project_id <- "PRE"
dep$project_id <- "PRE"


# Prep the dates 

# start dates
dep$start_date <- ymd_hms(dep$start_date)

# end dates
dep$end_date   <- ymd_hms(dep$end_date)

# camera days
dep$days <- interval(dep$start_date, dep$end_date)/ddays(1)

dep$feature_type <- substr(dep$placename,4,4)

# Image dates
# Image timestamp
img$timestamp <- ymd_hms(img$timestamp)
#
dep <- dep[duplicated(dep[,c("deployment_id", "placename")])==F,]
img <- left_join(img, dep[,c("deployment_id", "placename")])


```

The following map shows the locations of all the surveys included within this project to date. 

```{r map4, echo=F, class.source="Rmain"}

# # First, set a single categorical variable of interest from station covariates for summary graphs. If you do not have an appropriate category use "project_id".
# category <- "feature_type"
# 
# # We first convert this category to a factor with discrete levels
# dep[,category] <- factor(dep[,category])
# # then use the turbo() function to assign each level a color
# col.cat <- turbo(length(levels(dep[,category])))
# # then we apply it to the dataframe
# dep$colours <- col.cat[dep[,category]]

m <- leaflet() %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%  
  addTiles(group="Base") %>%     # Include a basemap option too
  addPolylines(data = trails, group = "trails", color="brown") %>% 
  addPolygons(data=plots, popup=plots$plot_id, group="plots",
              weight=3) %>% 
  addCircleMarkers(lng=locs_db$longitude, lat=locs_db$latitude,
                   # Co lour the markers depending on the 'feature type'
                   color="black",radius=3, stroke=F, fillOpacity=0.6,
                   # Add a popup of the placename and feature_type together
                   popup=paste(locs_db$plot_id, locs_db$original_treatment,
                        "<br>Long:",locs_db$longitude,
                        "<br>Lat:",locs_db$latitude),
                   group="survey_locs") %>%
  ## Add a legend explaining what is going on
  # addLegend("topleft", colors = col.cat,  labels = levels(dep[,category]),
  #                  title = category,
  #                  labFormat = labelFormat(prefix = "$"),
  #                  opacity = 1) %>%
  # 
  # add a layer control box to toggle between the layers
  addLayersControl(
                    baseGroups = c("Base", "Satellite"),
                    overlayGroups = c("plots","trails", "survey_locs"),
                    options = layersControlOptions(collapsed = FALSE)
      ) %>%
  addFullscreenControl()

m

```

## Historical survey timeline

**NOTE** We still need incorporate the vegetation data [Also - should we add historical dung beetle and butterfly data?]

```{r, include = F, echo = F}
  
# Birds ############################################################

bird_counts <- read_excel("data/Piro_Restoration_Experiment_BIRD_DATABASE.xlsx",
                      sheet="Bird_count_data")
bird_counts <- as.data.frame(bird_counts)

bird_counts$date <- ymd(bird_counts$date)
bird_counts <- bird_counts %>% drop_na(date)

# Note that SOME OF THE bird data has a leading zero. We should remove that
tmp1 <- substr(bird_counts$plot_id,1,1)
tmp2 <- as.numeric(substr(bird_counts$plot_id,2,3))
bird_counts$plot_id <- paste0(tmp1, tmp2)
bird_counts$site_date <- paste0(bird_counts$plot_id, "_", gsub("-", "", bird_counts$date))


# Bats ############################################################
# The bat count data
bat_counts <- read_excel("data/Piro_Restoration_Experiment_BATBOX_DATABASE.xlsx",
                      sheet="bat_monitoring")

bat_counts$date_check <- ymd(bat_counts$date_check)
bat_counts <- bat_counts %>% drop_na(date_check)
# Remove NA;s
bat_counts<- bat_counts[is.na(bat_counts$plot)==F,]

 
# Camera traps ######################################################
dep <- read_excel("data/Piro_Restoration_Experiment_CAMERA_TRAP_DEPLOYMENTS.xlsx",
                      sheet="deployment_data")
dep$`Start date` <- ymd(dep$`Start date`)
dep <- dep %>% drop_na(`Start date`)


locs <- read_excel("data/Piro_Restoration_Experiment_CAMERA_TRAP_DEPLOYMENTS.xlsx",
                      sheet="camera_locations")
                      
locs <- locs %>% drop_na(longitude)

# Amphibian data #####################################################
amphib_effort <- read_excel("data/Piro_Restoration_Experiment_AMPHIBIAN_DATABASE.xlsx",
                      sheet="visit_data", col_types = "text")

amphib_effort$date <- as.Date(as.numeric(amphib_effort$date), origin = as.Date("1899-12-30"))
amphib_effort <- amphib_effort %>% drop_na(date)


# Rapid vegetation surveys ###############################################
veg_cover <- read_excel("data/Piro_Restoration_Experiment_VEGETATION_MONITORING.xlsx",
                      sheet="rapid_vegetation_survey", col_types = "guess")

head(veg_cover)

# Sherman trapping - 1Pr0X70oLGreYE3tnq7zkF3FN7kD0oBd71ldeA3_dkBI

sherman_dep <- read_excel("data/Piro_Restoration_Experiment_SHERMAN_TRAPPING_DATABASE.xlsx",
                      sheet="deployment_data", col_types = "guess")

sherman_dep <- sherman_dep[is.na(sherman_dep$start_date)==F,]

sherman_cap <- read_excel("data/Piro_Restoration_Experiment_SHERMAN_TRAPPING_DATABASE.xlsx",
                      sheet="capture_data", col_types = "guess")


```


```{r}
# Make a plotly graph where the survey type is the y0axis and the date is the x axis

# The first bit of data form the whole project is:

survey_types <- c("Birds" = 1, "Bats" = 2, "Camera traps" = 3, "Amphibians" = 4,
                  "Small mammals" = 5)

fig <- plot_ly() %>%
  layout(
    title = "Survey Data Through Time",
    xaxis = list(title = "Year", range = c(ymd("2017-01-01"), Sys.time())),
    yaxis = list(title = "", tickvals = unname(survey_types), ticktext = names(survey_types))
  )

# add birds

fig <- fig %>%
      add_trace(
        x = bird_counts$date,
        y = survey_types[["Birds"]],
        type = "scatter",
        mode = "markers",
        marker = list(size = 10),
        name = "Birds"
      )

# Add bats

fig <- fig %>%
      add_trace(
        x = bat_counts$date_check,
        y = survey_types[["Bats"]],
        type = "scatter",
        mode = "markers",
        marker = list(size = 10),
        name = "Bats"
      )

# Add cameras

fig <- fig %>%
      add_trace(
        x = dep$`Start date`,
        y = survey_types[["Camera traps"]],
        type = "scatter",
        mode = "markers",
        marker = list(size = 10),
        name = "Cameras"
      )

# Add amphibs

fig <- fig %>%
      add_trace(
        x = amphib_effort$date,
        y = survey_types[["Amphibians"]],
        type = "scatter",
        mode = "markers",
        marker = list(size = 10),
        name = "Amphibians"
      )

fig <- fig %>%
      add_trace(
        x = sherman_dep$start_date,
        y = survey_types[["Small mammals"]],
        type = "scatter",
        mode = "markers",
        marker = list(size = 10),
        name = "Small mammals"
      )



fig
```

## Earthwatch survey timeline

Now lets zoom in on data collected since our collaboration with Earthwatch started:

```{r}
fig %>%
  layout(xaxis = list(range = c(as.Date("2025-02-01"), Sys.time() )),
         title = "Survey Data 2025")
```

# Bird surveys

## Earthwatch data

```{r, message=F, warning=F}
plots_centroid <- st_centroid(plots)
#head(bird_counts)

bird_effort <-bird_counts[, c("plot_id", "date", "site_date")]
bird_effort <- bird_effort[duplicated(bird_effort)==F,] 
bird_effort_2025 <- bird_effort[bird_effort$date>ymd("2025-01-01"),]
be_sum <-  bird_effort %>% group_by(plot_id) %>% summarise(Visits=n())
be_sum <- left_join(plots_centroid, be_sum)



# 2025 summary
#head(bird_effort_2025)
be_2025_sum <-  bird_effort_2025 %>% group_by(plot_id) %>% summarise(Visits=n())
be_2025_sum <- left_join(plots_centroid, be_2025_sum)
# Convert simple features collection to an sf dataframe
be_2025_sum$Visits[is.na(be_2025_sum$Visits)==T] <- 0


#2025 records
bird_counts_2025 <- bird_counts[bird_counts$date>ymd("2025-01-01"),]
#

```

Since January 2025, we have visited `r nrow(be_2025_sum[be_2025_sum$Visits>0,])` unique survey locations and performed `r nrow(bird_effort_2025)` point counts, and recorded `r length(unique(bird_counts_2025$common_name))` different species classifications. 

The distribution of survey effort is as follows:

```{r}
library(RColorBrewer)

# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
pal <- colorBin(palette = "YlOrRd", domain = be_2025_sum$Visits, bins = 10, pretty = TRUE)

# Create the leaflet map
leaflet(be_2025_sum) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = ~pal(Visits), 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, "<br> Survey Visits:", Visits)
  ) %>% 
  addLegend(
    pal = pal, 
    values = ~Visits, 
    title = "Number of Visits", 
    opacity = 1
  )
```

The distributions of species detected is as follows:

```{r}
bc_2025_sum <- bird_counts_2025 %>% group_by(common_name) %>% summarise(sample_frequency=n())

# Determine dynamic height based on number of species
num_species <- nrow(bc_2025_sum)
plot_height <- max(400, num_species * 18)  # Minimum height 400px, scales with species count
```


```{r, out.height=plot_height}
# Create a Plotly bar chart
plot <- bc_2025_sum %>%
  arrange(desc(sample_frequency)) %>%  # Sort by frequency
  plot_ly(
    x = ~sample_frequency, 
    y = ~common_name, 
    type = 'bar',
    orientation = 'h',
    marker = list(color = 'steelblue',
    height = plot_height)
  ) %>%
  layout(
    title = "Species Detection Frequency",
    xaxis = list(title = "Detection Frequency"),
    yaxis = list(title = "Species", categoryorder = "total ascending",
                 tickfont = list(size = 10)),
    barmode = 'group'
  )

# Display the plot
plot
```


## Historical 

```{r}
bc_sum <- bird_counts %>% group_by(common_name) %>% summarise(sample_frequency=n())

# Determine dynamic height based on number of species
num_species <- nrow(bc_sum)
plot_height <- max(400, num_species * 18)  # Minimum height 400px, scales with species count
```

Since the start of the project we have visited `r nrow(be_sum[be_sum$Visits>0,])` unique survey locations and performed `r nrow(bird_effort)` point counts, and recorded `r length(unique(bird_counts$common_name))` different species classifications. 

The survey effort (number of locations samples and number of point counts by year) are as follows:

```{r}
bird_effort$year <- year(bird_effort$date)

tmp <- bird_effort %>% group_by(year) %>% summarise(plots_visited=n_distinct(plot_id), total_point_counts=n(), )

knitr::kable(tmp,align = "lrr" ,caption = "Bird survey effort through time")
```

The frequency distributions of the species detected are as follows:

```{r, out.height=plot_height}
# Create a Plotly bar chart
plot <- bc_sum %>%
  arrange(desc(sample_frequency)) %>%  # Sort by frequency
  plot_ly(
    x = ~sample_frequency, 
    y = ~common_name, 
    type = 'bar',
    orientation = 'h',
    marker = list(color = 'steelblue',
    height = plot_height)
  ) %>%
  layout(
    title = "Species Detection Frequency",
    xaxis = list(title = "Detection Frequency"),
    yaxis = list(title = "Species", categoryorder = "total ascending",
                 tickfont = list(size = 10)),
    barmode = 'group'
  )

# Display the plot
plot
```


# Bat data

```{r}

# Why do we have NA's
tmp <- bat_counts %>% group_by(plot) %>% summarise(visits=n())

#kbl(unique(bat_counts$plot))

# Prep the next bubble
# NOTE I DO NOT TRUST THE LOCATION IN THE DATABASE. USE THE SHAPEFILE NYOU HAVE. 

bat_locs <- bat_counts[, c("plot", "latitude", "longitude")]

#take the first of each of these (most likely the most reliable)
bat_first <- bat_locs[duplicated(bat_locs$plot)==F,]


#bat_locs <- bat_locs[duplicated(bat_locs)==F,]


# Setup the date column
bat_counts$date_check <- ymd(bat_counts$date_check)
```

We have been collecting bat data from `r length(unique(bat_counts$plot))` bat boxes, and visited these locations `r max(tmp$visits)` times. They are distributed as follows:

```{r}

# Assuming be_2025_sum is already loaded as an sf dataframe

leaflet(data = bat_first) %>%
  addPolygons(data=plots, popup=plots$plot_id, group="plots") %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = 3,
    color = "darkred",
    fill = TRUE,
    fillOpacity = 0.5,
    popup = ~paste("Plot ID:", plot)
  ) 
  
# Remove the shit location data
bat_counts$latitude <- NULL
bat_counts$longitude <- NULL

bat_counts <- left_join(bat_counts, bat_first)

```

## Survey effort through time

```{r}
plot_types <- data.frame(locs = unique(bat_counts$plot), id=1:length(unique(bat_counts$plot)))

# Order
plot_types <- plot_types[order(plot_types$locs),] 

plot_height <- max(300, min(nrow(plot_types) * 30, 800))

fig <- plot_ly(height=plot_height) %>%
  layout(
    title = "Bat Survey Effort Through Time",
    xaxis = list(title = "Year", range = c(min(bat_counts$date_check), Sys.time())),
    yaxis = list(title = "Plot id", tickvals = plot_types$id, ticktext = plot_types$locs)
  )

# add birds
i <- 1
for(i in 1:nrow(plot_types))
{
    fig <- fig %>%
      add_trace(
        x = bat_counts$date_check[bat_counts$plot==plot_types$locs[i]],
        y = i,
        type = "scatter",
        mode = "markers",
        marker = list(size = 5),
        name = plot_types$locs[i]
      )
  
}

fig

```


## Overall bat occupancy through time

To understand the long term patterns in bat use of the nest boxes, we can look at the probability of a bat occupying the boxes or not through time: 

```{r}
bat_counts$binary <- NA
bat_counts$binary[bat_counts$presence_of_bats=="yes"] <- 1
bat_counts$binary[bat_counts$presence_of_bats=="no"] <- 0
bat_counts$month <- ym(substr(bat_counts$date_check,1,7))
tmp <- bat_counts[is.na(bat_counts$binary)==F,] %>% group_by(month) %>% summarise(occ=sum(binary)/n())

# Make the plot
plot_ly(
  data = tmp,
  x = ~month,
  y = ~occ,
  type = 'scatter',
  mode = 'lines+markers',  # line with points
  line = list(color = 'darkred'),
  marker = list(size = 8, color = 'darkred')
) %>%
  layout(
    title = "Bat occupancy Over Time",
    xaxis = list(title = "Date"),
    yaxis = list(title = "Occupancy",range = c(0, 1))
  )


```

## Treatment specific occupancy through time

```{r}

bat_counts$treatment <- substr(bat_counts$plot,1,1)

tmp <- bat_counts[is.na(bat_counts$binary)==F,] %>% group_by(month, treatment) %>% summarise(occ=sum(binary)/n())
tmp$treatment <- as.factor(tmp$treatment)

# Make the plot
plot_ly(
  data = tmp,
  x = ~month,
  y = ~occ,
  color= ~treatment,
  type = 'scatter',
  mode = 'lines+markers',  # line with points
  line = list(width=2),
  marker = list(size = 6)) %>%
  layout(
    title = "Bat occupancy Over Time",
    xaxis = list(title = "Date"),
    yaxis = list(title = "Occupancy",range = c(0, NA)),
    legend = list(title = list(text = "Treatment"))
  )


```

# Small mammal data

So far we have made `r length(unique(sherman_dep$deployment_id))` sherman trap deployments, across `r length(unique(sherman_dep$plot_id))` plots. 

The deployments we distributed as follows:

```{r}
library(RColorBrewer)

# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
n <- length(unique(sherman_dep$plot_id))
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
tmp <- data.frame(plot_id=unique(sherman_dep$plot_id), col=col_vector[1:n])
sherman_dep<- left_join(sherman_dep, tmp)
sherman_sf <- st_as_sf(sherman_dep, coords=c("longitude", "latitude"), crs=4326)


# Create the leaflet map
leaflet(sherman_sf) %>% 

  addPolygons(data=plots, popup=plots$plot_id, group="plots",
              weight=3, fillOpacity=0.05) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = sherman_sf$col, 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, trap_location)
  ) 
```

Top date we have recorded `r nrow(sherman_cap)` small mammals. They are as follows:

```{r}
tmp <- sherman_cap %>%  group_by(species) %>% summarise(count=n())
kbl(tmp)
```

Of these, `r length(sherman_cap$deployment_id[substr(sherman_cap$deployment_id,1,1)=="F"])` were in forest and `r length(sherman_cap$deployment_id[substr(sherman_cap$deployment_id,1,1)!="F"])` were in the plots. 

# Camera trap data

To date we have deployed `r nrow(dep)` cameras, at `r length(unique(dep$placename))` locations.

```{r}
# Pick the category you want to color
category <- "feature_type"

# We first convert this category to a factor with discrete levels
dep[,category] <- factor(dep[,category])
# then use the turbo() function to assign each level a color
col.cat <- turbo(length(levels(dep[,category])))
# then we apply it to the dataframe
dep$colours <- col.cat[dep[,category]]

m <- leaflet() %>%
  addProviderTiles(providers$Esri.WorldImagery, group="Satellite") %>%  
  addTiles(group="Base") %>%     # Include a basemap option too
  addCircleMarkers(lng=dep$longitude, lat=dep$latitude,
                   # Co lour the markers depending on the 'feature type'
                   color=dep$colours,
                   # Add a popup of the placename and feature_type together 
                   popup=paste(dep$placename, dep[,category])) %>%
  
  # Add a legend explaining what is going on
  addLegend("bottomleft", colors = col.cat,  labels = levels(dep[,category]),
                   title = category,
                   labFormat = labelFormat(prefix = "$"),
                   opacity = 1) %>%
  
  # add a layer control box to toggle between the layers
  addLayersControl(
                    baseGroups = c("Satellite", "Base"))

m
```

Check the deployments to make sure they occur where we expect:

```{r}
# Call the plot
p <- plot_ly()

# We want a separate row for each 'placename' - so lets turn it into a factor
dep$placename <- as.factor(dep$placename)

# loop through each place name
for(i in seq_along(levels(dep$placename)))
  {
      #Subset the data to just that placename
      tmp <- dep[dep$placename==levels(dep$placename)[i],]
      # Order by date
      tmp <- tmp[order(tmp$start_date),]
      # Loop through each deployment at that placename
      for(j in 1:nrow(tmp))
      {
        # Add a line to 'p'
        p <- add_trace(p, 
                       #Use the start and end date as x coordinates
                       x = c(tmp$start_date[j], tmp$end_date[j]), 
                       #Use the counter for the y coordinates
                       y = c(i,i), 
                       # State the type of chart
                       type="scatter",
                       # make a line that also has points
                       mode = "lines+markers", 
                       # Add the deployment ID as hover text
                       hovertext=tmp$deployment_id[j], 
                       # Color it all black
                       color=I("black"), 
                       # Suppress the legend
                       showlegend = FALSE)
      }
      
  }
# Add a categorical y axis
 p <- p %>%   layout(yaxis = list(

      ticktext = as.list(levels(dep$placename)), 

      tickvals = as.list(1:length(levels(dep$placename))),

      tickmode = "array"))


p
```

They look good so far!

Check the images occur in the right place:

```{r}
#Camera activity plot
# Make a separate plot for each 30 stations 
# Order by placename to make the graphs easier to follow
dep <- dep[order(dep$placename),]

# To do this make a plot dataframe
tmp <- data.frame("deployment_id"=unique(dep$deployment_id), "plot_group"=ceiling(1:length(unique(dep$deployment_id))/30))

dep_tmp <- left_join(dep,tmp, by="deployment_id")


# Make a colour palette for blanks vs. real detections
cols <- c("red", "blue")


for(i in 1:max(dep_tmp$plot_group))
{  
  # Call the plot
  
  #Subset the data to just that placename
  tmp <- dep_tmp[dep_tmp$plot_group==i,]
  # Order by placename 
  tmp <- tmp[order(tmp$placename),]
  p <- plot_ly() 
 # Loop through each deployment at that placename
  for(j in 1:nrow(tmp))
    {
        #Subset the image data
        tmp_img <- img[img$deployment_id==tmp$deployment_id[j],]
        
        if(nrow(tmp_img)>0)
        {
         
          p <- add_trace(p, 
                       #Use the start and end date as x coordinates
                       x = c(ymd_hms(tmp_img$timestamp)), 
                       #Use the counter for the y coordinates
                       y = rep(j, nrow(tmp_img)), 
                       # State the type of chart
                       type="scatter",
                       # make a line that also has points
                       mode = "markers", 
                       # Add the deployment ID as hover text
                       hovertext=paste(tmp_img$genus,tmp_img$species), 
                       # Color it all black
                       marker = list(color = cols[tmp_img$is_blank+1]), 
                       # Suppress the legend
                       showlegend = FALSE)
        }
        
       # Add a line to 'p'
        p <- add_trace(p, 
                       #Use the start and end date as x coordinates
                       x = c(tmp$start_date[j], tmp$end_date[j]+days(1)), 
                       #Use the counter for the y coordinates
                       y = c(j,j), 
                       # State the type of chart
                       type="scatter",
                       # make a line that also has points
                       mode = "lines", 
                       # Add the deployment ID as hover text
                       hovertext=tmp$deployment_id[j], 
                       # Color it all black
                       color=I("black"), 
                       # Suppress the legend
                       showlegend = FALSE)
      }
  # Add custom y axis labels  
  p <- p %>%   layout(yaxis = list(

      ticktext = as.list(tmp$deployment_id), 

      tickvals = as.list(1:nrow(tmp)),

      tickmode = "array"))
  
  print(p)
      
  
} 

```

There are some issues to sort out... we will do that later.

Filter down the image data to remove anything not identified to species:

```{r}
img_sub <- img %>% filter(is_blank==0,                # Remove the blanks
                          is.na(img$species)==FALSE, # Remove classifications which don't have species 
                          species!="sapiens",
                          species!="",
                          common_name!="No CV Result") 

#table(img_sub$common_name)
```

Which results in `r nrow(img_sub)` identifiable wildlife images.

```{r}
# Prep the analysis dataframes


# Remove any deployments without end dates
tmp <- dep[is.na(dep$end_date)==F,]

# Create an empty list to store our days
daily_lookup <- list()

# Loop through the deployment dataframe and create a row for every day the camera is active
for(i in 1:nrow(tmp))
{
  if(ymd(tmp$start_date[i])!=ymd(tmp$end_date[i]))
  {
    daily_lookup[[i]] <- data.frame("date"=seq(ymd(tmp$start_date[i]), ymd(tmp$end_date[i]), by="days"), "placename"=tmp$placename[i])
  }
}

# Merge the lists into a dataframe
row_lookup <- bind_rows(daily_lookup)

# Remove duplicates - when start and end days are the same for successive deployments
row_lookup <- row_lookup[duplicated(row_lookup)==F,]

###################################
# Create your independent detections
independent <- 30

# Check for a `group_size` variable? 
#table(img_sub$group_size)

# Check for a 'number_of_objects' variable
#table(img_sub$number_of_objects)

img_sub$animal_count <- img_sub$number_of_objects
img_sub$sp <- paste(img_sub$genus, img_sub$species, sep=".")
# Create your independent data

img_tmp <- img_sub %>%
              arrange(deployment_id) %>%        # Order by deployment_id
              group_by(deployment_id, sp) %>%   # Group species together
              mutate(duration = int_length(timestamp %--% lag(timestamp))) # Calculate the gap bet



library(stringr)
# Give a random value to all cells
img_tmp$event_id <- 9999

# Create a counter
counter <- 1

# Make a unique code that has one more zero than rows in your dataframe  
num_code <- as.numeric(paste0(nrow(img_sub),0))

# Loop through img_tmp - if gap is greater than the threshold -> give it a new event ID
for (i in 2:nrow(img_tmp)) {
  img_tmp$event_id[i-1]  <- paste0("E", str_pad(counter, nchar(num_code), pad = "0"))
  
  if(is.na(img_tmp$duration[i]) | abs(img_tmp$duration[i]) > (independent * 60))
    {
      counter <- counter + 1
    }
}

# Update the information for the last row - the loop above always updates the previous row... leaving the last row unchanged
   
 # group ID  for the last row
 if(img_tmp$duration[nrow(img_tmp)] < (independent * 60)|
    is.na(img_tmp$duration[nrow(img_tmp)])){
   img_tmp$event_id[nrow(img_tmp)] <- img_tmp$event_id[nrow(img_tmp)-1]
 } else{
   counter <- counter + 1
   img_tmp$event_id[nrow(img_tmp)] <- paste0("E", str_pad(counter, nchar(num_code), pad = "0"))
 }

# remove the duration column
img_tmp$duration <- NULL
 


 # find out the last and the first of the time in the group
  top <- img_tmp %>% group_by(event_id) %>% top_n(1,timestamp) %>% dplyr::select(event_id, timestamp)
  bot <- img_tmp %>% group_by(event_id) %>% top_n(-1,timestamp) %>% dplyr::select(event_id, timestamp)
  names(bot)[2] <- c("timestamp_end")
  
  img_num <- img_tmp %>% group_by(event_id) %>% summarise(event_observations=n()) # number of images in the event
  event_grp <- img_tmp %>% group_by(event_id) %>% summarise(event_groupsize=max(animal_count))

  # calculate the duration and add the other elements
  diff <-  top %>% left_join(bot, by="event_id") %>%
      mutate(event_duration=abs(int_length(timestamp %--% timestamp_end))) %>%
      left_join(event_grp, by="event_id")%>%
      left_join(img_num, by="event_id")

  # Remove columns you don't need
  diff$timestamp   <-NULL
  diff$timestamp_end <-NULL
  diff <- diff[duplicated(diff)==F,]
    # Merge the img_tmp with the event data
  img_tmp <- 
   left_join(img_tmp,diff,by="event_id")
  
  
  # Remove duplicates
ind_dat <- img_tmp[duplicated(img_tmp$event_id)==F,]

# Make a  unique code for ever day and deployment where cameras were functioning
tmp <- paste(row_lookup$date, row_lookup$placename)

#Subset ind_dat to data that matches the unique codes
ind_dat <- ind_dat[paste(substr(ind_dat$timestamp,1,10), ind_dat$placename) %in% tmp, ]

# Convert your species names to factors
ind_dat$sp <- as.factor(ind_dat$sp)

#Subset the columns
tmp <- dep[, c("project_id", "placename", "longitude", "latitude", "feature_type")]

# Remove duplicated rows
tmp<- tmp[duplicated(tmp)==F,]


#######################################################
#######################################################


# Total counts
  # Station / Month / deport / Species      
  tmp <- row_lookup
  
  # Calculate the number of days at each site  
  total_obs <- tmp %>% 
      group_by(placename) %>%
      summarise(days = n())
  
  # Convert to a data frame
  total_obs <- as.data.frame(total_obs)
  
  # Add columns for each species  
  total_obs[, levels(ind_dat$sp)] <- NA
  # Duplicate for counts
  total_count <- total_obs
  # Test counter
  i <-1
  # For each station, count the number of individuals/observations
  for(i in 1:nrow(total_obs))
    {
      tmp <- ind_dat[ind_dat$placename==total_obs$placename[i],]
      
      tmp_stats <- tmp %>%  group_by(sp, .drop=F) %>% summarise(obs=n(), count=sum(animal_count))
      
      total_obs[i,as.character(tmp_stats$sp)] <- tmp_stats$obs
      total_count[i,as.character(tmp_stats$sp)] <- tmp_stats$count
    }

```

```{r}
# Make a species list
# First define vector of the headings you want to see (we will use this trick a lot later on)
taxonomy_headings <- c("class", "order", "family", "genus", "species", "common_name")

# Subset the image data to just those columns
tmp<- ind_dat[,colnames(ind_dat)%in% taxonomy_headings]
# Remove duplicates
tmp <- tmp[duplicated(tmp)==F,]

# Create an ordered species list
sp_summary  <- tmp[order(tmp$class, tmp$order, tmp$family, tmp$genus, tmp$species),]
sp_summary$sp <- paste(sp_summary$genus, sp_summary$species, sep=".")




# Convert to long
long_obs <- total_obs %>% 
  pivot_longer(cols=sp_summary$sp,  # The columns we want to create into rows - species
               names_to="sp",       # What we what the number column to be called
               values_to = "count") # Takes the values in the species columns and calls them `count`


# We can them summaries those using dplyr
tmp <- long_obs %>%                   # Take the long observation data frame `long_obs` 
          group_by(sp) %>%            # Group by species
          summarise(count=sum(count)) # Sum all the independent observations

# Add it to the sp_summary dataframe
sp_summary <- left_join(sp_summary, tmp)

## Occupancy
# We use the mutate function to mutate the column
total_binary <-  total_obs %>%    # The total obs dataframe              
                    mutate(across(sp_summary$sp, ~+as.logical(.x)))  # across all of the species columns, make it binary

# Flip the dataframe to longer - as before
long_bin <- total_binary %>% 
  pivot_longer(cols=sp_summary$sp, names_to="sp", values_to = "count") # Takes the species names columns, and makes them unique rows with "sp" as the key 

# We can now sum the presence/absences and divide by the number of survey locations
tmp <- long_bin %>% 
  group_by(sp) %>% 
  summarise(occupancy=sum(count)/nrow(locs)) # divided the sum by the number of sites

# add the results to the sp_summary
sp_summary <- left_join(sp_summary, tmp)


###########################
# Comparison plot
# Lets put the dataframes in a sensible order
sp_summary <- sp_summary[order(sp_summary$count),]

yform <- list(categoryorder = "array",
              categoryarray = sp_summary$sp)

xform <- list(title="Captures")

# Capture rate
fig1 <- plot_ly(x = sp_summary$count, y = sp_summary$common_name, type = 'bar', orientation = 'h') %>% 
 layout(yaxis = yform, xaxis=xform)

yform <- list(categoryorder = "array",
              categoryarray = sp_summary$sp,
              showticklabels=F)
xform <- list(title="Occupancy")


# Occupancy
fig2 <- plot_ly(x = sp_summary$occupancy, y = sp_summary$common_name, type = 'bar', orientation = 'h') %>% 
 layout(yaxis = yform, xaxis=xform)

subplot(nrows=1,fig1, fig2, titleX = T) # We could stack them on top of one another using nrows=2
```


# Vegetation data

```{r}
veg_sum <- veg_cover %>% group_by(plot_id) %>% summarize("samples"=n())

veg_sum <- left_join(plots_centroid, veg_sum)

# Assuming veg_sum is already loaded and is an sf object
veg_sum <- veg_sum %>% 
  mutate(sample_status = ifelse(is.na(samples), "Not Surveyed", "Surveyed"))

```

To date we have performed surveys (blue dots) in the following `r length(veg_sum$sample_status[veg_sum$sample_status=="Surveyed"])` locations.

```{r}
# What 
# Define color palette
color_palette <- colorFactor(c("red", "blue"), domain = c("Not Surveyed", "Surveyed"))

# Create leaflet map
leaflet(veg_sum) %>%
  addTiles() %>%
  addCircles(
    radius = 8, # Adjust as needed
    color = ~color_palette(sample_status),
    fillColor = ~color_palette(sample_status),
    fillOpacity = 0.7,
    popup = ~paste(plot_id, " </br> Samples:", samples)
  ) %>%
  addLegend(
    position = "bottomright",
    pal = color_palette,
    values = veg_sum$sample_status,
    title = "Sample Presence",
    opacity = 1
  )

```

We could use grass cover a a proxy for how well the original treatments worked - i.e. if there is very high ground cover than would suggest the trees are not doing particularly well. I have explored the mean grass cover (number of quadrants which contain gress) as the metric for each location:

```{r}
veg_cover$plot_id <- as.factor(veg_cover$plot_id)

# Ensure veg_sum is loaded
grass_cover_filtered <- veg_cover %>%
  filter(ground_cover_category == "Grass") %>%
  group_by(plot_id, .drop = FALSE) %>%
  summarise(values = list(c(ground_cover, rep(0, max(0, 6 - length(ground_cover)))))) %>%
  unnest(values) %>%   # Unnest to expand list into rows
  group_by(plot_id) %>% summarise(grass_cover=mean(values))

grass_cover_filtered$treatment <- substr(grass_cover_filtered$plot_id,1,1)

# Add some jitter to the veg cover
grass_cover_filtered$grass_cover_jitter <- jitter(grass_cover_filtered$grass_cover, amount=0.1)

# Create Plotly Boxplot
plot_ly(grass_cover_filtered, x = ~treatment, y = ~grass_cover, type = "box") %>%
  layout(title = "Boxplot of Grass Cover per Plot",
         xaxis = list(title = "Treatment type"),
         yaxis = list(title = "Average Ground Cover"))%>%
  # Scatter plot layer (raw data)
  add_trace(
    data = grass_cover_filtered,
    x = ~treatment,
    y = ~grass_cover_jitter,
    type = "scatter",
    mode = "markers",
    name = "Raw Data",
    marker = list(color = "red", opacity = 0.6, size = 6),
    hoverinfo = "text",
    text = ~paste("Plot ID:", plot_id, "<br>Value:", grass_cover)
  ) %>%
  # Layout options
  layout(
    title = "Grass Cover per Plot",
    xaxis = list(title = "Plot ID"),
    yaxis = list(title = "Ground Cover Value"),
    showlegend = TRUE
  )
```

Some sites have low grass cover, but it doesnt appear to be linked to the original restoration methodology (L,M,H, N). High seems to be the worst, and medium the best!



```{r}

library(RColorBrewer)

# Add the site locations

grass_sf <- left_join(plots_centroid, grass_cover_filtered)


# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
pal <- colorBin(palette = "YlOrRd", domain = grass_sf$grass_cover, bins = 10, pretty = TRUE)

# Create the leaflet map
leaflet(grass_sf) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = ~pal(grass_cover), 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, "<br> Grass cover:", grass_cover)
  ) %>% 
  addLegend(
    pal = pal, 
    values = ~grass_cover, 
    title = "Grass cover", 
    opacity = 1
  )

```


We can do the same but with leaf litter cover (in this instance higher values are better):

```{r}

#table(veg_cover$ground_cover_category)
# Ensure veg_sum is loaded
leaflitter_cover_filtered <- veg_cover %>%
  filter(ground_cover_category == "Leaf litter") %>%
  group_by(plot_id, .drop = F) %>%
  summarise(values = list(c(ground_cover, rep(0, max(0, 6 - length(ground_cover)))))) %>%
  unnest(values) %>%   # Unnest to expand list into rows
  group_by(plot_id) %>% summarise(leaf_cover=mean(values))

leaflitter_cover_filtered$treatment <- substr(leaflitter_cover_filtered$plot_id,1,1)

# Add some jitter to the veg cover
leaflitter_cover_filtered$leaf_cover_jitter <- jitter(leaflitter_cover_filtered$leaf_cover, amount=0.1)

# Create Plotly Boxplot
plot_ly(leaflitter_cover_filtered, x = ~treatment, y = ~leaf_cover, type = "box") %>%
  layout(title = "Boxplot of leaf litter per Plot",
         xaxis = list(title = "Treatment type"),
         yaxis = list(title = "Average Ground Cover"))%>%
  # Scatter plot layer (raw data)
  add_trace(
    data = leaflitter_cover_filtered,
    x = ~treatment,
    y = ~leaf_cover_jitter,
    type = "scatter",
    mode = "markers",
    name = "Raw Data",
    marker = list(color = "red", opacity = 0.6, size = 6),
    hoverinfo = "text",
    text = ~paste("Plot ID:", plot_id, "<br>Value:", leaf_cover)
  ) %>%
  # Layout options
  layout(
    title = "Leaflitter Cover per Plot",
    xaxis = list(title = "Plot ID"),
    yaxis = list(title = "Leaflitter Cover Value"),
    showlegend = TRUE
  )
```


```{r}

ll_sf <- left_join(plots_centroid, leaflitter_cover_filtered)


# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
pal <- colorBin(palette = "YlOrRd", domain = ll_sf$leaf_cover, bins = 10, pretty = TRUE)

# Create the leaflet map
leaflet(ll_sf) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = ~pal(leaf_cover), 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, "<br> Leaflitter cover:", leaf_cover)
  ) %>% 
  addLegend(
    pal = pal, 
    values = ~leaf_cover, 
    title = "Leaf cover", 
    opacity = 1
  )

```


And shrub cover - note higher values of this are not necessarily good:

```{r}

#table(veg_cover$ground_cover_category)
# Ensure veg_sum is loaded
shrub_cover_filtered <- veg_cover %>%
  filter(ground_cover_category == "Plant/ shrub") %>%
  group_by(plot_id, .drop=F) %>%
  summarise(values = list(c(ground_cover, rep(0, max(0, 6 - length(ground_cover)))))) %>%
  unnest(values) %>%   # Unnest to expand list into rows
  group_by(plot_id) %>% summarise(shrub_cover=mean(values))

shrub_cover_filtered$treatment <- substr(shrub_cover_filtered$plot_id,1,1)

# Add some jitter to the veg cover
shrub_cover_filtered$shrub_cover_jitter <- jitter(shrub_cover_filtered$shrub_cover, amount=0.1)

# Create Plotly Boxplot
plot_ly(shrub_cover_filtered, x = ~treatment, y = ~shrub_cover, type = "box") %>%
  layout(title = "Boxplot of plant/shrub per Plot",
         xaxis = list(title = "Treatment type"),
         yaxis = list(title = "Average Ground Cover"))%>%
  # Scatter plot layer (raw data)
  add_trace(
    data = shrub_cover_filtered,
    x = ~treatment,
    y = ~shrub_cover_jitter,
    type = "scatter",
    mode = "markers",
    name = "Raw Data",
    marker = list(color = "red", opacity = 0.6, size = 6),
    hoverinfo = "text",
    text = ~paste("Plot ID:", plot_id, "<br>Value:", shrub_cover)
  ) %>%
  # Layout options
  layout(
    title = "Shrub Cover per Plot",
    xaxis = list(title = "Plot ID"),
    yaxis = list(title = "Ground Cover Value"),
    showlegend = TRUE
  )

# Remove the jitters

shrub_cover_filtered$shrub_cover_jitter <- NULL
grass_cover_filtered$grass_cover_jitter <- NULL
leaflitter_cover_filtered$leaf_cover_jitter <- NULL
```

```{r}

shrub_sf <- left_join(plots_centroid, shrub_cover_filtered)


# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
pal <- colorBin(palette = "YlOrRd", domain = shrub_sf$shrub_cover, bins = 10, pretty = TRUE)

# Create the leaflet map
leaflet(shrub_sf) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = ~pal(shrub_cover), 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, "<br> Shrub cover:", shrub_cover)
  ) %>% 
  addLegend(
    pal = pal, 
    values = ~shrub_cover, 
    title = "Shrub cover", 
    opacity = 1
  )

```


Canopy cover

```{r}

#table(veg_cover$ground_cover_category)
# Ensure veg_sum is loaded
canopy_cover_filtered <- veg_cover  %>%
  group_by(plot_id, .drop=F) %>%
  summarise(values = list(c(canopy_cover, rep(0, max(0, 6 - length(canopy_cover)))))) %>%
  unnest(values) %>%   # Unnest to expand list into rows
  group_by(plot_id) %>% summarise(canopy_cover=mean(values))

canopy_cover_filtered$treatment <- substr(canopy_cover_filtered$plot_id,1,1)

# Add some jitter to the veg cover
canopy_cover_filtered$canopy_cover_jitter <- jitter(canopy_cover_filtered$canopy_cover, amount=0.1)

# Create Plotly Boxplot
plot_ly(canopy_cover_filtered, x = ~treatment, y = ~canopy_cover, type = "box") %>%
  layout(title = "Boxplot of plant/canopy per Plot",
         xaxis = list(title = "Treatment type"),
         yaxis = list(title = "Average Ground Cover"))%>%
  # Scatter plot layer (raw data)
  add_trace(
    data = canopy_cover_filtered,
    x = ~treatment,
    y = ~canopy_cover_jitter,
    type = "scatter",
    mode = "markers",
    name = "Raw Data",
    marker = list(color = "red", opacity = 0.6, size = 6),
    hoverinfo = "text",
    text = ~paste("Plot ID:", plot_id, "<br>Value:", canopy_cover)
  ) %>%
  # Layout options
  layout(
    title = "canopy Cover per Plot",
    xaxis = list(title = "Plot ID"),
    yaxis = list(title = "Canopy Cover Value"),
    showlegend = TRUE
  )

# Remove the jitters

shrub_cover_filtered$shrub_cover_jitter <- NULL
grass_cover_filtered$grass_cover_jitter <- NULL
leaflitter_cover_filtered$leaf_cover_jitter <- NULL
```

```{r}

canopy_sf <- left_join(plots_centroid, canopy_cover_filtered)


# Assuming be_2025_sum is already loaded as an sf dataframe

# Define a color palette for the Visits column
pal <- colorBin(palette = "YlOrRd", domain = canopy_sf$canopy_cover, bins = 10, pretty = TRUE)

# Create the leaflet map
leaflet(canopy_sf) %>% 
  addTiles() %>% 
  addCircleMarkers(
    radius = 5, 
    color = ~pal(canopy_cover), 
    stroke = FALSE, 
    fillOpacity = 0.8,
    popup = ~paste(plot_id, "<br> canopy cover:", canopy_cover)
  ) %>% 
  addLegend(
    pal = pal, 
    values = ~canopy_cover, 
    title = "canopy cover", 
    opacity = 1
  )

```

Finally if we create a plot of grass vs. leaf litter, this should give us a good idea of where trees are coming back well:

```{r}


veg_final <- left_join(plots_centroid,shrub_cover_filtered) 
veg_final <- left_join(veg_final,grass_cover_filtered) 
veg_final <- left_join(veg_final,leaflitter_cover_filtered) 
#head(veg_final)
# Fill in the blanks
# Little loop to fill in the blanks
i <-4
for(i in 1:nrow(veg_final))
{
  if((is.na(veg_final$shrub_cover[i])+ is.na(veg_final$grass_cover[i]) + is.na(veg_final$leaf_cover[i]))<3){
      veg_final$shrub_cover[i][is.na(veg_final$shrub_cover[i])==T] <- 0
      veg_final$grass_cover[i][is.na(veg_final$grass_cover[i])==T] <- 0
      veg_final$leaf_cover[i][is.na(veg_final$leaf_cover[i])==T] <- 0
  }
    
}
veg_final_df <- as.data.frame(veg_final)

fig <- plot_ly(data = veg_final_df, 
               x = ~jitter(grass_cover), 
               y = ~jitter(leaf_cover), 
               type = 'scatter', 
               text = ~paste("Plot ID:", plot_id), 
               hoverinfo = 'text')

# Layout adjustments
fig <- fig %>% layout(
  title = "Grass Cover vs Leaf Litter Cover",
  xaxis = list(title = "Grass Cover"),
  yaxis = list(title = "Leaf Litter Cover")
)

# Display the plot
fig
```



